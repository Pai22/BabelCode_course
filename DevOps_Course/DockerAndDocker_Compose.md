## Docker

เทคโนโลยีคอนเทนเนอร์คือวิธีการห่อหุ้มแอปพลิเคชันเพื่อให้สามารถทำงานได้พร้อมกับ library ต่าง ๆ ที่ต้องใช้ รวมถึงทรัพยากรอื่น ๆ เช่น รูปภาพ ไฟล์ เป็นต้น โดยมีการทำงานแยกจาก Process อื่น ๆ คอนเทนเนอร์นั้นใช้ทรัพยากรน้อยกว่าเทคโนโลยี Virtualization มากจึงง่ายต่อการนำไปใช้ และด้วยความที่คอนเทนเนอร์ห่อหุ้มแอปพลิเคชั่นพร้อม dependencies ต่าง ๆ เอาไว้ มันจึงสะดวกต่อการนำไปทำงานในสภาพแวดล้อมที่แตกต่างกันทั้ง

1. ปัญหาของเทคโนโลยี Virtualization
สมมติว่าเรามีแอพพลิเคชัน A และ B ทั้งคู่ต่างต้องการใช้งานไลบรารี่คือ glibc ทั้งคู่ เพียงแต่แตกต่างเวอร์ชันกัน ในสถานการณ์แบบนี้เราจะไม่สามารถรันโปรแกรม A และ B พร้อมกันได้ เนื่องจากบนเครื่องของเราสามารถมี glibc ได้เพียงชุดเดียว

![lib-conflict-problem](/DevOps_Course//Images/lib-conflict-problem.png)

ความที่คอนเทนเนอร์แต่ละตัวมีการจับจองทรัพยากรที่น้อย เราจึงสามารถ Scale คอนเทนเนอร์ในเซอร์วิสใด ๆ จำนวนมากเพื่อรองรับโหลดของผู้ใช้งานได้ดีกว่าการใช้งาน VM

![lib-conflict-problem](/DevOps_Course//Images/container-scaling.png)

2. ประวัติย่อของเทคโนโลยีคอนเทนเนอร์

แนวคิดของคอนเทนเนอร์เริ่มขึ้นครั้งแรกในปี 1979 จากการเกิดขึ้นของระบบ chroot ในระหว่างการพัฒนา Unix V7 นี่เป็นจุดเริ่มต้นของการแยกการเข้าถึงไฟล์สำหรับแต่ละ Process ในหลายปีที่ผ่านมา มีการพัฒนาเทคโนโลยีคอนเทนเนอร์ที่หลากหลายรูปแบบ เช่น FreeBSD Jails ในปี 2000, Linux VServer ในปี 2001, Solaris Containers ในปี 2004, และ Google’s Process Containers ในปี 2006 และ LXC (LinuX Containers) ได้รับการดำเนินการในปี 2008 อย่างไรก็ตามจุดเปลี่ยนของการใช้เทคโนโลยีคอนเทนเนอร์แพร่หลายมากขึ้นพร้อมกับการมาของ Docker

Docker เป็นชุดของผลิตภัณฑ์ platform as a service (PaaS) ที่ได้สร้างการเปลี่ยนแปลงในโลกของการพัฒนาซอฟต์แวร์ด้วยวิธีการนำเสนอซอฟต์แวร์ในแพคเกจที่เรียกว่าคอนเทนเนอร์ Docker ก่อตั้งขึ้นเป็น DotCloud ในปี 2008 โดย Solomon Hykes ที่ปารีส เริ่มต้นจากการเป็น platform as a service (PaaS) ก่อนที่จะเปลี่ยนเป็นเทคโนโลยีคอนเทนเนอร์ในปี 2013

รุ่นเริ่มต้นของ Docker ออกมาในวันที่ 20 มีนาคม 2013 ซอฟต์แวร์ที่เป็นตัวจัดการและหัวใจสำคัญของการควบคุมคอนเทนเนอร์เรียกว่า `Docker Engine` Docker เป็นเครื่องมือที่ใช้ในการทำงานอัตโนมัติของการปรับใช้แอปพลิเคชันในคอนเทนเนอร์ที่ Lightweight เพื่อให้แอปพลิเคชันสามารถทำงานได้อย่างมีประสิทธิภาพในสภาพแวดล้อมที่แตกต่างกัน

เมื่อ Docker ปรากฏขึ้นในปี 2013 คอนเทนเนอร์ได้รับความนิยมอย่างรวดเร็ว การเติบโตของ Docker และการใช้คอนเทนเนอร์ไปด้วยกัน Docker ใช้ LXC ในช่วงเริ่มต้นและในภายหลังได้แทนที่ตัวจัดการคอนเทนเน

3. การทำงานของ Docker
เรามาเริ่มต้นด้วยการใช้คำสั่งง่าย ๆ เพื่อทำงานกับคอนเทนเนอร์ โดยออกคำสั่งคือ
```bash
docker run -p 5152:80 babelcoder/intro-to-devops-ui:1.0
```

คำสั่งดังกล่าวจะเป็นการบอก Docker Engine ซึ่งเป็นตัวควบคุมการทำงานของ Docker ให้สร้างสิ่งที่เรียกว่าคอนเทนเนอร์ อันเป็นสภาพแวดล้อมที่สมบูรณ์สำหรับการทำงานของแอปพลิเคชันขึ้นมา การจะสร้างคอนเทนเนอร์ใด ๆ ขึ้นมาได้นั้นต้องอาศัยสิ่งที่เรียกว่า Docker Image ที่เป็นเสมือนต้นแบบในการสร้างคอนเทนเนอร์ ดังนั้นคอนเทนเนอร์ใด ๆ ก็ตามที่สร้างมาจาก Docker Image เดียวกันย่อมมีลักษณะเหมือนกันทุกประการในตอนแรกเริ่ม แต่ภายหลังการใช้งานไปแล้ว คอนเทนเนอร์แต่ละตัวสามารถสร้างความแตกต่างของตนเองขึ้นได้

จากคำสั่งข้างต้นเรามี Docker Image ชื่อว่า `babelcoder/intro-to-devops-ui` ส่วน `1.0` ที่ต่อท้ายเราเรียกว่า Tag เป็นสิ่งเสมอเหมือนเวอร์ชันของ Image ดังนั้นคำสั่ง `docker run` ดังกล่าวจึงเป็นการบอกให้ Docker Engine ทำการสร้างคอนเทนเนอร์จาก Image ในเวอร์ชันดังกล่าวนั่นเอง

Image ที่มีชื่อว่า `babelcoder/intro-to-devops-ui` มีการบรรจุเว็บเซิฟเวอร์เป็นแอปพลิเคชันอยู่ภายใน เมื่อคอนเทนเนอร์ได้รับการทำงานเว็บเซอร์เวอร์ดังกล่าวจะทำงานที่พอร์ต 80 เพื่อให้ส่วนข้างนอกคอนเทนเนอร์สามารถเชื่อมต่อไปยังแอปพลิเคชันภายในที่ทำงานบนพอร์ต 80 ได้ เราต้องส่ง `-p` ไป กรณีของ `-p 5152:80` เป็นการบอกว่าข้างนอกคอนเทนเนอร์สามารถเข้าถึงแอปพลิเคชันภายในที่ทำงานบนพอร์ต 80 ได้ด้วยการใช้พอร์ตหมายเลข `5152`

![docker-ru](/DevOps_Course//Images/docker-run.png)

คำสั่ง `docker run` ต้องอาศัย Docker Image เป็นต้นแบบในการสร้างคอนเทนเนอร์ ดังนั้นคำสั่งดังกล่าวจะทำการตรวจสอบก่อนว่าบนเครื่องของเรามี Image ดังกล่าวอยู่แล้วหรือไม่ ถ้าไม่มีจะทำการดาวน์โหลด Image จาก Docker Hub พร้อมทำการจัดเก็บบนเครื่องของเรา ก่อนที่จะนำต้นแบบนี้ไปสร้างเป็นคอนเทนเนอร์ต่อไป

![how-docker-run-works](/DevOps_Course//Images/how-docker-run-works.png)

กระบวนการได้มาซึ่ง Docker Image นั้นจะต้องมีการเตรียมไฟล์หนึ่งที่ชื่อว่า Dockerfile ไฟล์ดังกล่าวจะบรรจุคำสั่งเป็นขั้นตอนสำหรับการสร้าง Docker Image

![how-docker-run-works2](/DevOps_Course//Images/how-docker-run-works2.png)

สำหรับคำสั่งสำคัญที่ใช้จัดการกับคอนเทนเนอร์ ได้แก่

```bash
$ # คำสั่งสำหรับการสร้างและรันคอนเทนเนอร์
$ docker run -p 5152:80 babelcoder/intro-to-devops-ui:1.0

Unable to find image 'babelcoder/intro-to-devops-ui:1.0' locally
1.0: Pulling from babelcoder/intro-to-devops-ui

$ # คำสั่งสำหรับตรวจสอบว่ามีคอนเทนเนอร์ไหนกำลังทำงานอยู่บ้าง
$ # amazing_lamarr ที่ปรากฎคือชื่อของคอนเทนเนอร์
$ docker ps

CONTAINER ID   IMAGE                               COMMAND                  CREATED         STATUS         PORTS                  NAMES
625f8285698b   babelcoder/intro-to-devops-ui:1.0   "/docker-entrypoint.…"   5 seconds ago   Up 5 seconds   0.0.0.0:5152->80/tcp   amazing_lamarr

$ # คำสั่งสำหรับหยุดการทำงานของคอนเทนเนอร์ แต่ไม่ได้ลบคอนเทนเนอร์ทิ้ง
$ docker stop amazing_lamarr

$ # คำสั่งเริ่มการทำงานของคอนเทนเนอร์ใหม่อีกครั้ง
$ docker start amazing_lamarr

$ # คำสั่งลบคอนเทนเนอร์
$ docker stop amazing_lamarr && docker rm amazing_lamarr
```

4. การใช้งาน Docker Compose
ในสถานการณ์ที่มีหลายเซอร์วิสหรือหลายคอนเทนเนอร์ การออกคำสั่ง `docker run` เพื่อสร้างคอนเทนเนอร์ของแต่ละเซอร์วิสนั้นนำมาซึ่งความยุ่งยาก เราจึงต้องการวิธีการใหม่ที่ช่วยให้การรันหลายคอนเทนเนอร์เป็นเรื่องที่ง่ายขึ้น

![docker-run-problem](/DevOps_Course//Images/docker-run-problem.png)

Docker มีฟีเจอร์หนึ่งที่เรียกว่า Docker Compose เป็นตัวช่วยในการสร้างคอนเทนเนอร์โดยใช้มุมมองของการประกาศเซอร์วิสต่าง ๆ ไว้ภายใต้ไฟล์ที่ชื่อว่า `docker-compose.yml` ส่วนสำคัญของไฟล์ดังกล่าวเริ่มที่ฟิลด์ที่ชื่อ `services` ที่ต้องทำการประกาศเซอร์วิสทั้งหมดที่จะให้สร้างเป็นคอนเทนเนอร์เพื่อทำงานพร้อมกัน จากภาพประกอบจะพบว่าเรามีเซอร์วิสทั้งหมด 3 ตัว คือ site, api และ db

![docker-compose](/DevOps_Course//Images/docker-compose.png)

แต่ละเซอร์วิสสามารถมีฟิลด์ชื่อ `image` เพื่อบอกว่าเมื่อทำการสร้างคอนเทนเนอร์ต้องอ้างอิงจาก Image ใด และมีส่วนของ `ports` เพื่อทำ Port Mapping เสมือนการใช้งาน `-p` ผ่านคำสั่งของ `docker run`

แอปพลิเคชันบางอย่างต้องอาศัยค่าตัวแปรที่เรียกว่า `Environment Variables` เพื่อเป็นค่ากำหนดการตั้งค่าให้การทำงานนั้นสมบูรณ์ เราสามารถส่งค่า Env นี้ไปยังคอนเทนเนอร์ในขณะที่คอนเทนเนอร์เริ่มทำงานได้ผ่านฟิลด์ที่ชื่อ `environment`

สุดท้ายเพื่อให้เกิดการสร้างคอนเทนเนอร์จากเซอร์วิสทั้งสาม เราจึงออกคำสั่งของ Docker Compose คือ docker compose up

5. การสร้าง Docker Images
การสร้าง Docker Image นั้นต้องอาศัยชุดคำสั่งซึ่งแสดงถึงขั้นตอนในการได้มาซึ่ง Image ชุดคำสั่งดังกล่าวจะเขียนไว้ในไฟล์ชื่อ Dockerfile คำสั่งแต่ละบรรทัดของ `Dockerfile` นั้นเมื่อแปลงเป็น Docker Image จะทำให้เกิดสิ่งที่เรียกว่า Layers ขึ้นมา เราจึงกล่าวได้ว่า Docker Image แท้ที่จริงแล้วก็คือ Layers หลาย ๆ Layers ที่เกิดจากชุดคำสั่งใน Dockerfile ประกอบรวมกันเป็น Image นั่นเอง

ภายหลังการสร้างชุดคำสั่งใน Dockerfile เราจะออกคำสั่ง `docker build` เพื่อทำการสร้าง Docker Image และเพื่อให้ Image ดังกล่าวสามารถถูกโหลดไปใช้งานได้ เราต้องส่ง Image ไปจัดเก็บไว้ในส่วนจัดเก็บบนคลาวด์ที่เรียกว่า `Docker Registry` โดยทั่วไปแล้ว Docker Registry ที่เป็นมาตรฐานและใช้งานโดยทั่วไปคือ Docker Hub เราใช้คำสั่ง `docker push` เพื่อนำส่ง Image ไปจัดเก็บยัง Docker Registry

![docker-image-layers](/DevOps_Course//Images/docker-image-layers.png)

สมมติว่าแอปพลิเคชันของเราพัฒนาขึ้นด้วยภาษา Go ภายในเครื่องของเราต้องมีการติดตั้ง Go Compiler เพื่อทำการคอมไพล์โปรแกรมของเราให้ออกมาเป็น Executable File

จากคำสั่งตามภาพต่อไปนี้คือการ Build โปรเจคให้ได้ Executable File ในชื่อของ api

![app-building](/DevOps_Course//Images/app-building.png)

จากขั้นตอนดังกล่าวเราจะทำการเปลี่ยนให้เป็นชุดคำสั่งของ Dockerfile ดังนี้

- `FORM golang`:1.22.1: เป็นการบอกว่า Image ของเราจะต่อยอดการทำงานมาจาก Image ที่ชื่อ golang โดยมีเวอร์ชันของแท็กคือ 1.22.1
- `WORKDIR /app`: สร้างโฟลเดอร์คือ /app และย้ายการทำงานไปยังโฟลเดอร์ดังกล่าว
- `COPY . .`: ให้ทำการคัดลอกไฟล์ต่าง ๆ ทั้งหมดมาวางที่ /app
- `RUN go mod download`: ออกคำสั่ง go mod download
- `RUN CGO_ENABLED=0 go build -o api`: ออกคำสั่ง CGO_ENABLED=0 go build -o api
- `CMD ["/app/api"]`: เมื่อคอนเทนเนอร์ได้รับการรัน ให้ออกคำสั่ง /app/api เพื่อรัน Executable File

![dockerfile](/DevOps_Course//Images/dockerfile.png)

ตามที่กล่าวไปแล้วข้างต้น คำสั่งต่าง ๆ ใน Dockerfile จะเกิดผลลัพธ์เป็น Layers ต่าง ๆ ใน Image ผลลัพธ์

![cmd-to-layers](/DevOps_Course//Images/cmd-to-layers.png)

โดยแต่ละ Layers ของ Image จะถูกแคชค่าไว้หากไม่เกิดการเปลี่ยนแปลงใด ๆ ในการ build ครั้งถัดไปจะไม่ทำการประมวลผลลัพธ์ Layer นั้นใหม่ หากแต่จะใช้งานค่าที่เคยแคชเอาไว้แทน กรณีที่คำสั่งใดมีการเปลี่ยนแปลงจะต้องทำการประมวลผลใหม่เพื่อแคชค่าใหม่ ส่วนของ Layer ถัดไปแม้จะไม่เปลี่ยนแปลงก็จะไม่นำผลลัพธ์จากแคชมาใช้แล้ว

การโปรแกรมด้วยภาษา Go จะมีส่วนของการใช้งานไลบรารี่ภายนอกต่าง ๆ ส่วนของไลบรารี่ใด ๆ ที่มีการใช้งานในโปรเจคจะถูกบันทึกไว้ในไฟล์ go.mod และ go.sum การที่เราเขียนคำสั่งใน Dockerfile เป็น `COPY . .` เพื่อทำการคัดลอกไฟล์ทั้งหมดก่อน แล้วจึงตามด้วย `RUN go mod download` จึงทำให้คุณสมบัติของการแคชนั้นไม่ได้รับการปฏิบัติที่ดีพอ ลองจินตนาการถึงสถานการณ์ทั่วไปที่ไลบรารี่ไม่ได้ถูกเพิ่ม ลบออก หรือเปลี่ยนแปลงบ่อยนัก เพียงแต่โค้ดของโปรแกรมส่วนอื่นต่างหากที่เปลี่ยนแปลง ในการ build รอบถัดไปจะไม่สามารถใช้ค่าแคชของ Layer `COPY . .` ได้ เพราะมีบางไฟล์ถูกแก้ไขแล้ว ผลลัพธ์ที่ตามมาคือ Layer ด้านล่างจะถูกลบออกจากแคชด้วยเป็นผลให้คำสั่ง `RUN go mod download` ต้องทำงานใหม่เพื่อดาวน์โหลดไลบรารี่ใหม่ ทั้ง ๆ ที่ความจริงแล้วส่วนของไลบรารี่ไม่ได้มีการเปลี่ยนแปลงแต่อย่างใด

![dockerfile-caching-problem](/DevOps_Course//Images/dockerfile-caching-problem.png)

เพื่อให้สถานการณ์ดังกล่าวได้รับการแก้ไข เราควรทำการคัดลอก go.sum และ go.mod พร้อมคำสั่ง go mod download ไว้เป็น Layer ด้านบนเพราะส่วนนี้เปลี่ยนแปลงน้อยจึงควรเก็บเป็นค่าแคชไว้นาน ๆ จากนั้นจึงทำการคัดลอกไฟล์อื่นที่เหลือ เมื่อเป็นเช่นนี้หากมีไฟล์อื่นใดนอกเหนือจาก go.sum และ go.mod เปลี่ยนแปลง Layer ของ go mod download จะไม่ได้รับผลกระทบ

![dockerfile-caching](/DevOps_Course//Images/dockerfile-caching.png)

ปัญหาต่อมาของการประกาศ Dockerfile คือการควบคุมขนาดของ Image ผลลัพธ์

เมื่อเราพิจารณาถึงการใช้งานของแอปพลิเคชัน เราจะพบว่าแท้จริงแล้วโปรแกรมของเราทำงานได้ผ่านการรันไฟล์ /app/api จึงไม่มีความจำเป็นใด ๆ ที่ Image ของเราต้องมีส่วนของ Go Compiler หรือไฟล์ซอร์จโค้ดอื่นใด แต่เนื่องจากช่วงแรกก่อนที่ /app/api จะเกิดขึ้นเราต้องการซอร์จโค้ดและ Go Compiler เพื่อให้เราสามารถคอมไพล์โปรแกรมได้ เราจึงทำการนิยาม Image ตั้งต้นเป็น `golang:1.22.1` ที่มี Go Compiler ติดมาด้วย โดยเราใช้ `AS` เพื่อทำการประกาศชื่อเรียกของส่วนนี้ว่า builder

```dockerfile
FROM golang:1.22.1 AS builder

WORKDIR /app

COPY go.mod go.sum ./
RUN go mod download

COPY . .
RUN CGO_ENABLED=0 go build -o api
```
ภายหลังการคอมไพล์เสร็จสิ้น ไม่มีความจำเป็นที่ต้องรันคอนเทนเนอร์ผ่าน Go Compiler หรือใช้ซอร์จโค้ดอีกต่อไป สิ่งที่เราต้องทำถัดไปคือทำอย่างไรก็ได้เพื่อสร้าง Image ให้มีเฉพาะ /app/api เพื่อให้ Image มีขนาดเล็กที่สุด

Docker มีฟีเจอร์สำหรับการ build หลายครั้งเรียกว่า Multi-stage Build โดยเราสามารถทำการ build ในครั้งที่สองด้วยการคัดลอกเฉพาะไฟล์ผลลัพธ์ที่ต้องการออกมารันในคอนเทนเนอร์ได้

![multi-stages-build](/DevOps_Course//Images/multi-stages-build.png)

จากภาพด้านบน ส่วนที่สองเราใช้ Image ตั้งต้นคือ `alpine:3.19` ที่มีขนาดเล็กกว่าเพราะไม่มี Go Compiler ติดมาด้วย แล้วทำการออกคำสั่ง `COPY --from=builder /app/api ./` เพื่อคัดลอกเฉพาะไฟล์ที่ต้องการคือ /app/api จาก builder มาใช้งาน ผลลัพธ์สุทธิของ Multi-stage Build จึงทำให้ Image ผลลัพธ์มีขนาดที่เล็กลง

ในการสั่ง build Image นั้นเราจะใช้คำสั่ง `docker build -t babelcoder/intro-to-devops-api:1.0 .` เมื่อ `babelcoder/intro-to-devops-api` คือชื่อของ Image ที่เราต้องการ ส่วน 1.0 คือเวอร์ชันของแท็ก ในขณะที่ `.` คือตำแหน่งของโฟลเดอร์ที่เราเรียกว่า Build Context

ส่วนของ Build Context คือโฟลเดอร์ที่เป็นจุดเริ่มต้นของการ build โดยทั่วไปโฟลเดอร์ดังกล่าวจะมีไฟล์ Dockerfile อยู่ เมื่อใดก็ตามที่มีการอ้างอิงถึงไฟล์ใด ๆ ใน Dockerfile ตำแหน่งในการค้นหาก็คือ Build Context นั่นเอง

การออกคำสั่ง `COPY . .` จะทำให้ทุกไฟล์ใน Build Context เข้าไปอยู่ใน Image ผลลัพธ์ หากเราไม่ต้องการให้ไฟล์ใดถูกนำไปใช้งาน ให้ระบุรายการของไฟล์เหล่านั้นใน `.dockerignore`

![dockerignore](/DevOps_Course//Images/dockerignore.png)

6. การเผยแพร่ Docker Images
เราจะทำการ Push Image ของเราไปยังบริการของ Docker Hub โดยให้ทำการสมัครสมาชิกให้เรียบร้อยก่อนแล้วจึงใช้ชื่อ account ของเราเป็นส่วนเริ่มต้นหน้า / ในตอน build Image

```bash
docker build -t babelcoder/intro-to-devops-api:1.0 .
```
จากนั้นให้ทำการเข้าสู่ระบบ โดยออกคำสั่ง `docker login`

```bash
$ docker login

Username: xxxxxx
Password: xxxxxx
Login Succeeded
```

ทำการ Push Image ขึ้นไปยัง Docker Hub ผ่านคำสั่ง

```
$ docker push babelcoder/intro-to-devops-api:1.0

```

เมื่อกลับไปยังเว็บของ Docker Hub จะพบกับรายละเอียดของ Image เรา

![docker-hub](/DevOps_Course//Images/docker-hub.png)